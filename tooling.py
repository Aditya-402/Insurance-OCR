import sqlite3
import json
import logging
import os
from dotenv import load_dotenv

# --- Configuration ---
# Load environment variables from .env
load_dotenv()

DB_PATH = os.getenv("DB_PATH", "claim_database.db")
ALLOWED_TABLE = 'ClaimsData'
# --- End Configuration ---

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def execute_sql_query(sql_query: str) -> str:
    """
    Executes a read-only (SELECT) SQL query against the ClaimsData table
    in the SQLite database (using the fixed path) and returns results as JSON.
    Performs security validation before execution.

    Args:
        sql_query: The SQL SELECT query generated by the LLM.

    Returns:
        A JSON string representation of the query results or an error message.
    """
    logging.info(f"Received SQL query for validation: {sql_query}")
    logging.info(f"Using database at path: {DB_PATH}")

    # --- !! CRITICAL SECURITY VALIDATION !! ---
    normalized_query = sql_query.strip().upper()

    # 1. Basic Check: Only allow SELECT statements
    if not normalized_query.startswith("SELECT"):
        error_msg = "Invalid query: Only SELECT statements are allowed."
        logging.error(error_msg)
        return json.dumps({"error": error_msg})

    # 2. Disallow Modification Keywords (extra safety)
    disallowed_keywords = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER', 'CREATE', 'ATTACH', 'DETACH', 'VACUUM', 'PRAGMA']
    for keyword in disallowed_keywords:
        if f' {keyword} ' in normalized_query or normalized_query.startswith(keyword + ' ') or normalized_query.endswith(' ' + keyword):
            error_msg = f"Invalid query: Modifying or disallowed keyword '{keyword}' found."
            logging.error(error_msg)
            return json.dumps({"error": error_msg})

    # 3. Table Check: Ensure only the allowed table is queried.
    # Normalizing by removing quotes for table name check
    table_check_query = normalized_query.replace('"', '').replace('`', '').replace('[', '').replace(']', '')
    allowed_table_upper = ALLOWED_TABLE.upper()
    from_clause_index = table_check_query.find("FROM ")

    # Ensure 'FROM ALLOWED_TABLE' is present. This is a simplified check.
    # A more robust check would involve parsing the SQL, but for this specific use case
    # and given the LLM is prompted to use FROM ALLOWED_TABLE, this should be sufficient.
    # We are checking for `FROM ALLOWED_TABLE_NAME` and not just `ALLOWED_TABLE_NAME`
    # to avoid false positives if the table name appears in a column name or string literal.
    
    # A simple way to check if the FROM clause correctly specifies the allowed table
    # This assumes the table name directly follows "FROM ".
    # It might need adjustment if aliases or more complex FROM clauses are used by the LLM.
    if from_clause_index == -1 or \
       not table_check_query[from_clause_index:].startswith(f"FROM {allowed_table_upper}"):
        # Check if the allowed table name is present *somewhere* after FROM,
        # which could indicate an aliased table or schema-qualified name.
        # This part is tricky without full SQL parsing. For now, we'll be strict.
        # If the LLM is well-behaved and always uses `FROM ClaimsData`, this check is simpler.
        if allowed_table_upper not in table_check_query[from_clause_index:]:
             error_msg = f"Invalid query: Must query from the '{ALLOWED_TABLE}' table directly (e.g., FROM {ALLOWED_TABLE}). Query: {sql_query}"
             logging.error(error_msg + f" (Normalized query for table check: {table_check_query})")
             return json.dumps({"error": error_msg})
        # If ALLOWED_TABLE is found after FROM but not immediately, it could be an alias.
        # For now, we accept this but log it. If this proves problematic, stricter parsing is needed.
        logging.warning(f"Query for '{ALLOWED_TABLE}' might be using an alias or complex FROM clause: {sql_query}")


    logging.info("SQL query passed basic validation.")
    # --- End Security Validation ---

    try:
        if not os.path.exists(DB_PATH):
             error_msg = f"Database file not found at the specified path: {DB_PATH}"
             logging.error(error_msg)
             return json.dumps({"error": error_msg})

        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute(sql_query)
        results = cursor.fetchall()
        column_names = [description[0] for description in cursor.description or []]
        conn.close()

        list_of_dicts = [dict(zip(column_names, row)) for row in results]
        logging.info(f"Query executed successfully. Rows returned: {len(list_of_dicts)}")
        return json.dumps(list_of_dicts)

    except sqlite3.Error as e:
        error_msg = f"Database error: {e}. Query attempted: {sql_query}"
        logging.error(error_msg)
        return json.dumps({"error": error_msg})
    except Exception as e:
        error_msg = f"An unexpected error occurred during SQL execution: {e}"
        logging.error(error_msg)
        return json.dumps({"error": error_msg})

if __name__ == '__main__':
    print(f"\n--- Testing Tool Function (using DB: {DB_PATH}) ---")
    if not os.path.exists(DB_PATH):
        print(f"Creating dummy database {DB_PATH} for testing...")
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        # Create the ALLOWED_TABLE (ClaimsData)
        cursor.execute(f'''
            CREATE TABLE IF NOT EXISTS {ALLOWED_TABLE} (
                ClaimID TEXT PRIMARY KEY,
                PatientName TEXT,
                ProcedureCode TEXT,
                AmountBilled REAL,
                "Service Date" TEXT,  -- Example of a column name needing quotes
                "Notes.Detail" TEXT   -- Example of a column name needing quotes
            )
        ''')
        # Insert some dummy data
        dummy_data = [
            ('101', 'John Doe', 'A123', 1500.75, '2023-01-15', 'Initial consultation notes here.'),
            ('102', 'Jane Smith', 'B456', 320.00, '2023-01-20', 'Follow-up. Patient recovering well.'),
            ('103', 'Alice Brown', 'C789', 875.50, '2023-02-01', None), # No notes
            ('104', 'Bob White', 'A123', 1600.00, '2023-02-05', 'Repeat procedure. See attached X-Rays.'),
            ('105', 'Charlie Green', 'D012', 50.25, '2023-02-10', 'Lab test results.')
        ]
        for record in dummy_data:
            cursor.execute(f"INSERT INTO {ALLOWED_TABLE} (ClaimID, PatientName, ProcedureCode, AmountBilled, \"Service Date\", \"Notes.Detail\") VALUES (?, ?, ?, ?, ?, ?)", record)
        conn.commit()
        conn.close()
        print(f"Dummy database {DB_PATH} with table '{ALLOWED_TABLE}' created and populated.")
    else:
        print(f"Using existing database: {DB_PATH}")

    # Test cases
    print("\n--- Test Cases ---")
    valid_query_all = f"SELECT * FROM {ALLOWED_TABLE}"
    print(f"Test 1 (Valid - All Data): {valid_query_all}")
    print(f"Result: {execute_sql_query(valid_query_all)}\n")

    valid_query_specific_cols = f'SELECT ClaimID, PatientName, "Service Date" FROM {ALLOWED_TABLE} WHERE AmountBilled > 1000'
    print(f"Test 2 (Valid - Specific Columns & Condition): {valid_query_specific_cols}")
    print(f"Result: {execute_sql_query(valid_query_specific_cols)}\n")
    
    valid_query_quoted_col = f'SELECT "Notes.Detail" FROM {ALLOWED_TABLE} WHERE ClaimID = "101"'
    print(f"Test 3 (Valid - Quoted Column Name): {valid_query_quoted_col}")
    print(f"Result: {execute_sql_query(valid_query_quoted_col)}\n")

    invalid_query_update = f"UPDATE {ALLOWED_TABLE} SET PatientName = 'Test' WHERE ClaimID = '101'"
    print(f"Test 4 (Invalid - UPDATE): {invalid_query_update}")
    print(f"Result: {execute_sql_query(invalid_query_update)}\n")

    invalid_query_wrong_table = "SELECT * FROM OtherTable"
    print(f"Test 5 (Invalid - Wrong Table): {invalid_query_wrong_table}")
    print(f"Result: {execute_sql_query(invalid_query_wrong_table)}\n")

    # Test with a query that might be problematic for simple string matching if not careful
    # Example: SELECT notes FROM ClaimsData WHERE notes LIKE '%FROM OtherTable%'
    # Our current validation for table name is simple and might need enhancement for such complex cases.
    # For now, the prompt engineering for the LLM should guide it to generate straightforward queries.

    # Test a query that should fail due to non-existent column (simulating a typo the LLM might make)
    query_with_typo = f"SELECT NonExistentColumn FROM {ALLOWED_TABLE} WHERE ClaimID = '101'"
    print(f"Test 6 (Database Error - Non-existent Column): {query_with_typo}")
    print(f"Result: {execute_sql_query(query_with_typo)}\n")
    
    # Test a syntactically incorrect SQL query
    syntactically_incorrect_query = f"SELEC ClaimID FRM {ALLOWED_TABLE}"
    print(f"Test 7 (Database Error - Syntax Error): {syntactically_incorrect_query}")
    print(f"Result: {execute_sql_query(syntactically_incorrect_query)}\n")

    print("--- End of Tests ---")